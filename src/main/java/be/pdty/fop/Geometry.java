package be.pdty.fop;
import java.awt.BasicStroke;
import java.awt.Shape;
import java.awt.geom.Area;
import java.awt.geom.Line2D;
import java.awt.geom.Path2D;
import java.awt.geom.PathIterator;
import java.util.ArrayList;
import java.util.List;

/**
 * Geometry.
 */
public class Geometry
{

  private static void appendSegment(float c1x,float c1y,float c2x,float c2y,float nx,float ny,float offset,int joinType,boolean first,Path2D.Float target) {
    //Current segment
    float cdx=c2x-c1x;
    float cdy=c2y-c1y;
    float clength=(float)Math.sqrt(cdx*cdx+cdy*cdy);
    cdx=cdx/clength;
    cdy=cdy/clength;
    float lc2x=c2x+cdy*offset;
    float lc2y=c2y-cdx*offset;
    
    //Next segment
    float ndx=nx-c2x;
    float ndy=ny-c2y;
    float nlength=(float)Math.sqrt(ndx*ndx+ndy*ndy);
    ndx=ndx/nlength;
    ndy=ndy/nlength;
    float ln1x=c2x+ndy*offset;
    float ln1y=c2y-ndx*offset;

    //Miter junction point
    float mdx=cdy+ndy;
    float mdy=-(cdx+ndx);
    float mLength=(float)Math.sqrt(mdx*mdx+mdy*mdy);
    if(mLength>0) {
      mdx/=mLength;
      mdy/=mLength;
    }
    
    //This gives us the cosine of the half-angle. Note that it can be zero!
    float cos=cdy*mdx-cdx*mdy;
    
    if(cdy*ndx-cdx*ndy>=0) {
      //A concave point. Draw via the original (non-extended) point as
      //per http://www.me.berkeley.edu/~mcmains/pubs/DAC05OffsetPolygon.pdf
      if(first) {
        target.moveTo(lc2x,lc2y);
      } else {
        target.lineTo(lc2x,lc2y);
      }
      target.lineTo(c2x,c2y);
      target.lineTo(ln1x,ln1y);
    } else {
      //A convex point
      switch(joinType) {
        case BasicStroke.JOIN_BEVEL:
          //Simple bevel, we'll go to our end first, then to the beginning of next line.
          if(first) {
            target.moveTo(lc2x,lc2y);
          } else {
            target.lineTo(lc2x,lc2y);
          }
          target.lineTo(ln1x,ln1y);
          break;
        case BasicStroke.JOIN_MITER:
        default:
          //Miter.
          float lim=4f;
          //The length of the miter is extent/cos, and we allow up to lim*extent.
          //Therefore if extent/cos>lim*extent (or cos*lim<1), we'll revert to bevel.
          if(cos*lim<1f) {
            //Bevel
            if(first) {
              target.moveTo(lc2x,lc2y);
            } else {
              target.lineTo(lc2x,lc2y);
            }
            target.lineTo(ln1x,ln1y);
          } else {
            //Actual miter.
            float mitX=c2x+mdx*offset/cos;
            float mitY=c2y+mdy*offset/cos;
            if(first) {
              target.moveTo(mitX,mitY);
            } else {
              target.lineTo(mitX,mitY);
            }
          }
          break;
        case BasicStroke.JOIN_ROUND:
          //Let's go to the beginning of the joint first.
          if(first) {
            target.moveTo(lc2x,lc2y);
          } else {
            target.lineTo(lc2x,lc2y);
          }

          //Draw the circle.
          if(offset>0) {
            //Starting angle
            float angle=(float)Math.atan2(-cdx,cdy);
            //Length of arc
            float arc=(float)Math.acos(cos)*2;
            //Arc increment
            float increment=10f/offset;
            if(increment>0.5f) increment=0.5f;
            //Ending angle
            float angleEnd=angle+arc-increment;
            
            //Let's try to ensure the partial increment
            //due to rounding error is evenly spread on two ends
            float off=arc-((int)(arc/increment+0.5f))*increment;
            angle+=off/2;
            
            while(angle<angleEnd) {
              angle+=increment;
              float x=(float)(Math.cos(angle)*offset+c2x);
              float y=(float)(Math.sin(angle)*offset+c2y);
              target.lineTo(x,y);
            }
            target.lineTo(ln1x,ln1y);
          }
          break;
      }
      
    }
  }

  private static float area(List<Line2D.Float> lines) {
    float ans=0;
    for(Line2D.Float line:lines) {
      ans+=(line.x1*line.y2)-(line.x2*line.y1);
    }
    return ans;
  }
  
  private static Area renderSimpleShape(List<Line2D.Float> lines,float offset,int joinType) {
    Path2D.Float ans = new Path2D.Float(Path2D.WIND_NON_ZERO);
    
    for(int i=0;i<lines.size();i++) {
      int nextIndex=i+1;
      if(nextIndex==lines.size()) nextIndex=0;
      
      Line2D.Float current=lines.get(i);
      Line2D.Float next=lines.get(nextIndex);
      
      appendSegment(current.x1,current.y1,current.x2,current.y2,next.x2,next.y2,offset,joinType,i==0,ans);
    }
    
    //Creating an area with non-zero winding will perform a proper cleanup of the overlapping areas
    //generated by the concave points.
    return new Area(ans);

  }
  
  /**
   * Return an area that is the offset of the given input (closed) shape.
   * @param shape input shape.
   * @param offset offset (must be greater than 0).
   * @param joinType joinType, use constants from BasicStroke.
   * @return offset area.
   */
  public static Area offsetShape(Shape shape,float offset,int joinType) {
    PathIterator pi=shape.getPathIterator(null,1f);
    float[] data=new float[2];
    
    float firstX=0f;
    float firstY=0f;
    float previousX=0f;
    float previousY=0f;
    List<List<Line2D.Float>> simpleShapes=new ArrayList<>();
    List<Line2D.Float> current=new ArrayList<>();
    
    while(!pi.isDone()) {
      int type=pi.currentSegment(data);
      float targetX=0f;
      float targetY=0f;
      switch(type)
      {
        case PathIterator.SEG_MOVETO:
          if(current.size()>0) {
            simpleShapes.add(current);
            current=new ArrayList<>();
          }
          firstX=data[0];
          firstY=data[1];
          targetX=firstX;
          targetY=firstY;
          break;
        case PathIterator.SEG_LINETO:
          targetX=data[0];
          targetY=data[1];
          if(previousX!=targetX || previousY!=targetY) {
            current.add(new Line2D.Float(previousX,previousY,targetX,targetY));
          }
          break;
        case PathIterator.SEG_CLOSE:
          targetX=firstX;
          targetY=firstY;
          if(previousX!=targetX || previousY!=targetY) {
            current.add(new Line2D.Float(previousX,previousY,targetX,targetY));
          }
          if(current.size()>0) {
            simpleShapes.add(current);
            current=new ArrayList<>();
          }
          break;
      }
      
      previousX=targetX;
      previousY=targetY;
      
      pi.next();
    }    
    
    Area finalArea=new Area();
    for(int s=0;s<simpleShapes.size();s++) {
      if(area(simpleShapes.get(s))>0) {
        finalArea.add(renderSimpleShape(simpleShapes.get(s),offset/2.0f,joinType));
      }
    }
    
    return finalArea;
  }
  
}
